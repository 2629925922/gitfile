小常识:
源文件： 将编写好的代码保存到一个文件里，这个保存好代码的文件叫做源文件。
源程序 : 编写好的代码，这个代码没有编译。  
机器语言和汇编语言为 面向机器的语言。  
高级语言是一种脱离对计算机硬件要求，能在任何计算机上运行的计算机语言。是一种面向问题的语言。分两大类 ：面向过程和面向对象，c语言是面向过程的语言。
高级语言的执行，不能在计算机上直接运行，必须要翻译转化为等价的二进制指令才能运行，翻译的方式分为两种，一种是解释性( python )，一种是编译性( c语言)。
一般再整形后面加个后缀L或者l,表示长整型常量，如 0L ,0123L , 0X64L
~ 是位运算符 ，是二进制中的按位取反运算符，也就是0 变1 ，1 变 0.
c 语言中逻辑值 真 用 非0表示，逻辑 假 用 0 表示，逻辑表达式 真 用 1，逻辑表达式假 用 0表示。
n个字符串占字节位 为 n+1
定义变量时，未指定存储类型符号时，默认为自动存储类型，类型符号是auto
存储类型有:  auto（自动型） register （寄存器型） static （静态型） extern （外部参照型）
一字节(byte) = 8 bit
数值是以补码表示的:
1.正数的补码和原码相同:
2.负数的补码：将该数的绝对值的二进制形式按位取反再加1
c语言数组越界的避免方法:  https://www.cnblogs.com/CodeWorkerLiMing/p/12007345.html
const关键字及其作用: http://c.biancheng.net/view/217.html
例如: 求-10 的补码
10的原码：                        00001010
取反:                                  11110101
再加1，得-10的补码:         11110110

十进制 转化 16 进制 :  直接除16，反向取余
  例:    60536  转化16进制          60536/16 = 3783....8      3783/16=236.....7    236/16=14....12   14/16=0....14   （14 十六进制为E 12 十六进制为C，所以答案为EC78）

8进制 转化 10进制 : 
0302(8进制)  =  194 (10进制)
0302 = 0*8^3+3*8^2+0*8^1+2*8^0 = 0+192+0+2 = 194

1e-6 是1乘以10的-6次方。由于 float有效位是6~7位，所以1e-6 经常被用作float类运算的精度值。

void   为空类型的说明符
未初始化的全局变量的默认值是 0，而未初始化的局部变量的值却是垃圾值（任意值）

int 整型    -2147483648~~ 2147483647  
unsigned int  无符号整型     0~~2147483647      （无符号从0开始）

for(;;)              为无限循环

运算器的功能是 算术运算和逻辑运算
根据程序的不同用途，将软件分为 系统软件和应用软件
制作一张能启动计算机的系统盘中，可以使用的命令是 FORMAT A:/S

一. 语言基本概述
一个c语言由一个或者多个函数构成，必须有一个main函数，程序从main函数开始，也从main函数结束。
函数由函数首部跟函数体两部分组成。
语句已分号结束，一行可以写多条语句，一条语句也可以多行写。
c语言的运行过程四个步骤:  编辑，编译，连接，执行
c语言的的基本组成单位是函数

二.数据类型，运算符，表达式
数据类型： 基本类型，构造类型，指针类型，空类型
标示符:  变量名不能以数字开开头，大写跟小写视为不同字符，不能用关键字作为标示符
常量:  算术型常量跟字符型常量   (算术型常量 :1231 454   字符型常量:  "hello word" "13215665")
符号常量:   #define  标示符 常量名       // #define PI  3.14     符号常量一般用大写字母
变量:  整数型变量，实型变量，字符型变量
整数常量:    十进制整数常量 : 645  -145     八进制整数常量: 032 065      十六进制整数常量: 0xd
实型常量:  所有实数的集合   (1.十进制小数形式: -2.001  30.0       2.  指数形式:  小数+e+整数     2.1e2  -2.8e-2)
字符常量:  单引号括起来的
字符串常量:   双引号括起来的
自增自减:  ++1 --1  先加减后运算   1++ 1-- 先运算后加减    i = 5  k = (++i)+(++i)+(i++)    最后 i为8  k为21      

一个c语言程序函数由声明部分和执行部分组成
c语言分5类:  控制语句，函数调用语句，表达式语句，复合语句，空语句
控制语句:    if语句，switch语句，do while语句，while语句，for语句，break语句，goto语句，continue语句，return语句
函数调用语句:  由函数名(实际参数表)；        printf("hello word") 
表达式语句 :  由表达式+分号组成           x=z+b
复合语句:   由多条语句和一对大括号组成起来的一条语句，
{
	a = z+z;
	b = g+g;
	printf("%d%d",a,b);
}
空语句:  只有分号"；"组成的语句

逗号表达式 :  x=(3,4)    结果x=4。     逗号表达式的值括号里最后一个值

三个基本结构:  顺序结构，选择结构，循环结构
顺序结构:   按先后顺序逐条执行
选择结构:   又称分支结构和判断结构，依据给出的条件来进行判断
循环结构:   又称重复结构，在一定条件下反复执行某一部分的操作

赋值语句: 赋值表达式的末尾没有分号，赋值语句的末尾必须有分号

putchar: 输出一个字符
getchar: 输入一个字符
 
格式化输出函数   ：  pirntf(格式控制，输出列表)        scanf(格式控制，输出列表)
格式控制:  普通字符("ada"),转义字符("\n")，格式声明("%d,%f") 
输出列表:  可以是常量，变量，表达式
%2d    从右对齐两个字符长度
%-2d   负号从左对齐，两个字符长度
%10.5f    右对齐10个字符长度，小数点后5位
%lf    打印double类型

三. 选择结构程序设计
关系表达式:   表达式 关系运算符 表达式     2 < 5
逻辑运算符:    逻辑非 !  逻辑与 && 逻辑或 ||     (逻辑非最高，逻辑与次之，逻辑或最低)
逻辑表达式:   由逻辑运算符组成的表达式      2 && 0 为0        (&&都为真才是真(1)，||只有一个是真才是真(1), 真(1，非0)，假(0))
单分支语句：  if - else
双分支语句:  if - else if
多分支语句:   if - else if  else 
三目运算符:   表达式1 ? 表达式2 : 表达式3    
             if(表达式1) printf(表达式2)
             else printf(表达式3)
自减自增运算符:    a=3; b=a++; printf("%d，%d",a,b)        #结果是4，3    本身值变，赋予的表达式的值不变

异或运算符"∧"也称XOR运算符。它的规则是若参加运算的两个二进位同号，则结果为0（假）；异号则为1（真）。即 0∧0＝0，0∧1＝1， 1^0=1，1∧1＝0。
0异或任何数，其结果=任何数
1异或任何数，其结果=任何数取反
任何数异或自己，等于把自己置0



四. 循环控制
while(表达式) { 语句 }    ：当表达式为真就打印语句，为假就退出循环
do { 语句 } while(表达式)   :  先执行语句，再进行表达式的判断，为真就执行循环，假就退出循环
do { printf(123) } while(！3)       #该条件为假，3 为非0，!非0是0，既flase
for(循环变量赋初始值,循环条件,循环变量)       ： 程序首先计算第一个表达式的值，接着计算第二个表达式的值，当第二个表达式为真程序就执行循环体的语句，然后再计算第三个表达式的值。
for 循环中的“表达式1（初始化条件）”、“表达式2(循环条件)”和“表达式3（自增或自减）”都是可选项，都可以省略（但分号;必须保留）。
for循环的3个表达式可以同时省略，相当于:   while(1)
goto :   无条件跳转语句
实例:  
goto x;                                 # x: 代码表示goto语句要跳转到的位置
printf("不执行该语句")；
x:
	printf("跳转到我这条语句里")
breadk和continue的区别:  continue语句只会结束本次循环，而不是终止整个循环。 break是直接结束整个循环过程。
const 定义的是常变量
size_t 可以存储任意类型    (利用%zu来打印size_t类型,sizeof操作符的结果类型是size_t)     在<stddef.h>的头文件中   
有符号：即有正号和负号
无符号：即只有正号没有负号
举个例子，16位整型数
int i; i 为有符号整数，取值范围：-32768——32767
unsigned int j; j 为无符号整数，取值范围：0——65535



五. 数组
一维数组:  数组的定义(int a[20])  数组下标可以是整数常数或者表达式，下标最大不能超界。
数组初始化: 1.全部初始化(int a[3]={1,2,3})   2.部分初始化(int a[10]={1,2,3,4,5,6}  #里面剩下的内容全部为0)       3.
二维数组:  数组名[行下标][列下标]      下标可以是整数常量或者表达式   下标从0开始              1.所有赋值(int a[2][3]={{1,2,3},{25,5,9}})  2.所有数据写一个括号里(int a[2][3]={12,5,21,5,2,6,1231,2,5})     3.部分赋值(int a[2][3]={2},{7})    对二维数组赋值时，可以不指定第一维的长度，但是必须指定二维的长度
字符数组: 一个元素存放一个字符       char a[5]={'a','2','8','aa'}
字符串数组:     一个字符串数组存放一个字符串      char a[10]={"i love you"}
%c 输入输出一个字符       printf("%c",a[1])
%s 输入输出字符串(当%s来进行格式化字符串时，不需要加地址运算符)           printf("%s",a)
puts函数：   把字符数组中的字符输出来      puts(a)
gets函数：   接受一个字符串到字符数组里              gets(a)                  #gets函数不以空格做为字符串输入结束的标志，是以回车来作为字符串输入结束的标志
strcat函数:    strcat(字符数组名1，字符数组名2)         把1跟2的字符数组进行结合起来
strcpy函数：    strcpy(字符数组名1，字符数组名2)                把字符数组名2的内容复制到字符数组名1里，要求数组1有足够的长度
strlen函数:     strlen(字符数组名)              测出字符串的长度(不包含字符串结束标志'\0')
'\0' 是字符串的结束符，任何字符串之后都会自动加上'\0'。如果字符串末尾少了‘\0’转义字符，则其在输出时可能会出现乱码问题。
普通局部变量是再熟悉不过的变量了，在任何一个函数内部定义的变量（不加static修饰符）都属于这个范畴。编译器一般不对普通局部变量进行初始化，也就是说它的值在初始时是不确定的，除非对其显式赋值。
普通局部变量存储于进程栈空间，使用完毕会立即释放。
静态局部变量使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。
静态局部变量的效果跟全局变量有一拼，但是位于函数体内部，就极有利于程序的模块化了


六. 指针
指针:  定义一个变量，在内存中会分配一个地址，访问这个地址就可以找到所要的变量，这个变量的地址称为变量的指针 (在程序中，编译后的文件已经讲变量名转换为该变量在内存中存放的地址，对变量值的存取通过地址进行的，通过地址访问指定的存储单元可以说是指向该内存单元，一个变量的地址称为变量的指针)
指针变量:  格式:  类型说明 * 变量名  一个变量专门用来存放另一个变量的地址，它就是指针变量，* 表示变量是一个指针变量，变量名即为指针变量名(指针变量同普通变量不一样，使用之前必须定义，并且要赋予具体的值，未经赋值的指针不能使用，给指针变量赋值只能赋予地址，而不能赋予任意其他数据)
一维数组的数组名表示的就是数组的第一个元素的地址。
int *p,a;     //定义指针跟变量
p=&a;        //进行指针p的初始化
*p=10;              //给指针p对象赋值，相当于a=10
printf("a的值为: %d",a);
return 0;
指针类型:  专门用来存放内存单元的变量类型称为指针类型  (int * // char *)
int a,b,*p,*pp;
p = &a,pp = &b   //&a是变量a的值，&b是变量b的值。   (在定义完指针变量之后再赋值注意不要加"*"，不允许吧一个真实数赋值给指针变量)
指针的自增自减:  指针变量：int *p,i=5; p=&i; p++   (指针p是指向i的地址，这里的p++不是简单在地址上加1，而是指向下一个基本类型数的地址)
一维数组和指针:   （ int *p,a[10]; p = a; ）  与  ( int *p,a[10]; p = &a[0])   一样
数组名就是该数组在内存中的首地址，a[0] 也是 该数组的首地址，所以一样
printf("%5d",*(p++))  和  for循环中的 printf("%5d",*(p+i))  一样都是输出数组a和数组b中对应的元素
int a[10],*p; p = a;
&跟*运算符优先级相同，&*p 先进行*运算，得到p指针变量 a变量的值，然后&取得其值在内存中的地址。
*&p 而是先进行计算&运算，得到指针变量p a的内存中的地址，然后再进行*运算，得到a地址中内存的内容
二维数组指针：   类型标识符(*指针变量名)[长度]
int b[2][3]      # b是该二维数组的首地址 同 &b[0][0]  b+i是第i的首地址  b[i] <=> *(b+i)   b[i]+j <=> *(b+i)+j  
*(p+i)+j 是二维数组的第i行第j列的地址  而*(*(p+i)+j)是二维数组的第i行第j列的元素值 同 *(a[i]+j)
void指针:  一种特殊的指针，表示为"无类型指针".  
任何类型的指针都可以直接赋值给 void 指针，而无需进行其他相关的强制类型转换.   
void *p1;
int *p2;
…
p1 = p2;
void 指针赋值给其他类型的指针，必须进行强制类型转换.
void *p1;
int *p2;
…
p2 = (int*)p1;
下面的代码在 VC++2010 中将提示“expression must be a pointer to a complete object type”的错误信息。
void * p;
p++;      // ANSI：错误
p+= 1;      // ANSI：错误
但是在GNU(gcc)中，编译器认为void * 跟 char * 一样。不会报错
详解:  http://c.biancheng.net/view/365.html
null指针: 对于空（null）指针的概念，在 C 标准中明确地定义：值为 0 的整型常量表达式，或强制（转换）为“void*”类型的此类表达式，称为空指针常量。当将一个空指针常量赋予一个指针或与指针作比较时，将把该常量转换为指向该类型的指针，这样的指针称为空指针。空指针在与指向任何对象或函数的指针作比较时保证不会相等。
根据上面的定义，我们可以对空指针做如下几点剖析：
1) 每一种指针类型都有一个空指针，它与同类型的其他所有指针值都不相同。
2) 由系统保证空指针不指向任何实际的对象或函数，也就是说，任何对象或者函数的地址都不可能是空指针，空指针与任何对象或函数的指针值都不相等。因此，取地址操作符 & 永远也不能得到空指针，同样对 malloc() 函数的成功调用也不会返回空指针，但如果调用失败，则 malloc() 函数返回空指针。
3) 空指针表示“未分配”或者“尚未指向任何地方”。它与未初始化的指针有所不同，空指针可以确保不指向任何对象或函数，而未初始化指针可能指向任何地方。
4) 0、0L、'\0'、3-3、0*17以及(void*)0等都是空指针常量，则：
int *p;
p=0;
/*或者*/
p=0l;
/*或者*/
p='\0';
/*或者*/
p=3-3;
/*或者*/
p=0*17;
/*或者*/
p=(void*)0;
常数 0 是一个空指针常量，而 NULL 仅仅是它的一个别名。
详解:  http://c.biancheng.net/view/364.html
双重指针(指向指针的指针):  一个指针变量指向别另一个指针变量时，称之为指向指针的指针变量
格式:  类型说明符  **指针变量名
int **p1,*p,a[10];
p = a    // p = &a[0] p指向存放a数组首地址
p1 = &p     // p1指向存放p的地址
这里的值 **p跟*p 就是s数组的值。
把a数组的首地址赋值给指针变量p，又将指针变量p的地址给p1，通过这个双重指针变量p1来访问数组中的元素，*p1的含义，*p1指向的是指针变量p所存放的内容也就是数组a的首地址，所以在*p1前加个*就是取得地址的内容。
字符串有两种表示方式:  一种是字符数组，另一种是字符指针
char string[]= "afadsfas"
char *str = "sadfasf"    (字符串指针极速数组的首地址)
字符指针变量与字符数组的区别:  字符数组由若干个元素组成，每个元素里存放一个字符，而字符指针变量只存放字符串的首地址，不是整个字符串。
对数组初始化一定要用static，指针变量不需要
static char *name[]= {"li jiang","wang xu","zhang jie"}
数组在定义和编译时分配内存单元，而指针变量定义后最好将其初始化，否则指针变量会指向一个不确定的内存段，将会破环程序。
指针变量的值是可以改变的，而字符数组名所代表的字符串首地址却是不能改变的。
数组指针:  int(*p)[长度]               //一般多指向是一维数组的指针变量
指针数组:  int *p[长度]
C语言指针常量和指向常量的指针详解 :http://c.biancheng.net/view/367.html
const char * p 是常量指针 
char const * p 是指向常量的指针
记忆:  const 常量 * 指针，当const 在*之前就是常量指针，而const在*之后，就是指针常量.
(1)式定义了一个常量指针，即指向一个常量的指针，指向的内容是常量，不可修改，放在常量区的，但指针本身可以修改，即*p='b'，是非法的，*p是p指向的常量的第一个字符，是个常量，不能改变的。p=&q这是可以的，指针可以指向不同的地址。
(2)式定义了一个指针常量，即指针本身是个常量，不可修改，但指针指向的内容可以修改,一开始定义时让它指向数组a. *p='b'这是可以的，但p=&b是非法的。
(3) char*p定义的是一个指针变量p,指向字符串abc的首地址。这里特别要注意，在C语言中，(3)式定义的是一个常量字符串，它被放在静态存储区的常量区进行存储，而p是一个指针变量，放在栈上。如果*p='b',在编译时能通过，但在运行时就会出现错误，因为你试图去改变常量区的内容。
指针函数： 顾名思义，它的本质是一个函数，不过它的返回值是一个指针。 
格式:  定义返回类型 *函数名(参数,...)
//指针函数的实用(求阶乘) 
int *factorial(int a);           //进行指针函数的声明
int *factorial(int a)           //对指针函数进行定义
{
	static int b;             //static 对b变量进行静态化处理 
	b = a;
	int *p = &b;
	if(a<0) printf("输入的数字不能小于0！！");
	for(int i=1;i<a;i++)
	{
		b *= i; 
	}
	
	return p;
} 
int main()
{
	int a;
	printf("input a number：");
	scanf("%d",&a);
	int *pp = factorial(a);                //定义一个指针指向函数返回值，然后进行打印
	printf("%d factorial is %d",a,*pp);
	return 0;
}
因此，在使用指针函数的时候，一定要避免出现返回局部变量指针的情况。
使用static进行处理这个问题:  原因是一旦使用了static去修饰变量，那么该变量就变成了静态变量。而静态变量是存放在数据段的，它的生命周期存在于整个程序运行期间，只要程序没有结束，该变量就会一直存在，所以该指针就能一直访问到该变量。
函数指针: 函数指针 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。我们知道，函数的定义是存在于代码段，因此，每个函数在代码段中，也有着自己的入口地址，函数指针就是指向代码段中函数入口地址的指针。
格式:  返回值类型 (*p)(参数类型,...)                //函数指针的定义
函数指针变量 =  函数名;        //进行函数指针初始化
include <stdio.h>
int max(int a, int b)
{
    return a > b ? a : b;
}

int main(void)
{
    int (*p)(int, int); //函数指针的定义
    //int (*p)();       //函数指针的另一种定义方式，不过不建议使用
    //int (*p)(int a, int b);   //也可以使用这种方式定义函数指针
    
    p = max;    //函数指针初始化

    int ret = p(10, 15);    //函数指针的调用
    //int ret = (*max)(10,15);
    //int ret = (*p)(10,15);
    //以上两种写法与第一种写法是等价的，不过建议使用第一种方式
    printf("max = %d \n", ret);
    return 0;
}
回调函数:  回调函数就是一个通过指针函数调用的函数。其将函数指针作为一个参数，传递给另一个函数。回调函数并不是由实现方直接调用，而是在特定的事件或条件发生时由另外一方来调用的。
int aa(int a);
int sum(int (*p)(int),int b);
int aa(int a)
{
	return a*a;
} 
int sum(int (*p)(int),int b)
{
	return p(b); 
}
int main()
{
	int b=2;
	printf("sum is %d",sum(aa,b));
	return 0;
}
int aa(int a);
int sum(int (*p)(int),int b);
int aa(int a)
{
	return a*a;
} 
int sum(int (*p)(int),int b)
{
	return p(b); 
}
int main()
{
	int b=2;
	printf("sum is %d",sum(aa,b));
	return 0;
}




七. 函数
void sum（int a，int b）｛....｝          //此时函数没有返回值
如果不需要参数  则int sum（void）｛...｝      //此时void的意义为空，就是没有参数的意思
如果都不要  则为void sum（void）； 
主函数可以调用其他函数，其他函数也可以相互调用。
把被调用的函数称为下层函数。
函数名: 就是函数的标识符。
main函数返回值为整型，可以由两个参数，一个是整数，一个是指向字符数组的指针。
一个函数的定义分为函数头和函数体两个部分。
返回值类型   函数名(参数列表)
{
	函数体(实现特定功能的过程)
}
函数头是标识一个函数代码的开始，这个一个函数的入口。分为返回值类型，函数名，参数列表。
无参函数:  没有参数的函数
空函数:  没有任何返回内容的函数
在编写函数时，先对函数进行声明，再对函数进行定义。声明是一定要以；分号作为语句的结尾。
将函数的定义放在调用函数之前，就不需要进行函数的声明，此时函数的定义就包含了函数的声明。
返回语句: 
利用返回语句就能立即从所在函数中退出，返回到调用的程序中
返回语句可以返回值，进函数值赋给调用的表达式中。 返回类型为void的函数就是没有返回值。
return 0 跟 return(0) 是一样的
当在定义函数时明确指出函数返回值的类型。
如果自定义的函数返回值类型与最终return语句返回值的类型不一致，但是可以通过类型转换后，函数返回类型和定义类型一致。
数值型数据可以自动进行类型转换，既函数定义的返回值类型决最终返回值的类型。
形式参数: 形式上的参数
实际参数: 实际存在的参数
定义或声明函数时，参数为形参。当调用函数时，此时函数为实际参数。
函数调用时，使用变量，常量或数组元素作为函数参数时，将实参的值复制到形参相应的存储单元，既实参跟形参分别占用不同的存储单元。这种方法是称为“值传递”。  特点: 单向传递。
函数的嵌套调用：  既在被调用函数时又调用其他函数。
函数的递归调用:  一个函数在它的函数体内调用它自身时被称为递归调用。
被调用函数通过 return 语句向调用者返回值，return 语句的后面可以跟任何表达式：
函数未定义返回值类型时，默认返回int类型。
科学计数法打印使用%e
内部函数:  改函数只能在本所在的源文件中使用，在函数名前加static进行修饰，又称静态函数(在不同的源文件中有同名的内部函数，这些同名的函数是互不干扰)
外部函数: 可以被其他源文件所调用的函数，extern关键字修饰(在定义函数时，如果不指明函数是外部是内部，默认指定函数是外部函数，定义外部函数可以省略extern关键字)
局部变量: 在函数内部定义的变量，函数的形式参数也属于局部变量(一个局部变量的作用范围可以由包含变量的一对括号所限定)
不同作用域的变量可以使用相同的标识符，也就是可以为变量起相同名字(内层作用域中的变量是可以屏蔽掉外层的作用域的那个变量，直到结束内层作用域为止)
全局变量: 变量在所有函数外层声明，是可以在程序的任何位置进行访问。
结构体: 是一种构造类型，其成员也是一个基本数据类型，也可以是一个构造类型
声明结构体使用的关键字是struct
struct 结构体名
{
	成员列表
}
声明结构体时，注意大括号后面又一个分号。
关键字struct后跟一个结构类型名
结构体变量的定义:  struct 结构类型名 结构体变量名
结构体变量不只一个，可以有多个
struct 结构体名
{
	成员列表
}结构体变量名1，结构体变量名2，结构体变量名3
定义结构体变量 可以在定义结构体时直接定义变量，也可以在main函数里定义
结构体变量赋值: struct student student1={值1,值2，...}
定义的变量后面使用等号，然后将其初始化的值放在大括号中，每个数据要与定义结构体变量后进行初始化
结构体数组: 结构体变量替换为数组  struct student student1[10];
struct student
{
	成员列表
}student1[10];

初始化结构体数组:  为数组进行初始化，最外层大括号包括几个元素，就是包括大括号
struct 结构体名
{
	成员列表
}student1[2]={
	{值1,值2，..},
	{值1，值2，..}
};
struct student student1[2]={{值1，值2,...}{值1,值2，...}};
在定义数组时，也可以不指定数组中的元素个数，编译器会根据后面的初始化值列表中给出的元素个数来确定数组中的元素的个数。

结构体指针： struct 结构体类型名 *指针名
struct Date
{
	int year;
	int month;
	int day;
};

int main()
{
	struct Date date1={2021,1,22};
	struct Date *p;
	p = &date1;
	printf("日期: %d-%d-%d",(*p).year,(*p).month,(*p).day);
	return 0;
}
*p必须一定要是大括号，因为.运算符的优先级是最高的
声明结构体位置可以在main函数外也可以在main函数里(外面是全局，里是局部)
访问结构体里的结构成员
第一种是点运算符
结构体变量名.结构体成员名
第二种是指向运算符
结构体变量名->结构体成员名 
结构体嵌套 :
//struct Date
//{
//	int year;
//	int month;
//	int day;	
//}; 
//struct Student
//{
//	char name[10];
//	int age;
//	struct Date date;
//	char genter[10];
//	char massage[10];
//}student1;
//
//int main()
//{
//	printf("请录入你的信息: \n");
//	printf("name: \n");
//	scanf("%s",&student1.name);
//	printf("age :\n");
//	scanf("%d",&student1.age);
//	printf("year : \n");
//	scanf("%d",&student1.date.year);
//	printf("month : \n");
//	scanf("%d",&student1.date.month);
//	printf("day : \n");
//	scanf("%d",&student1.date.day);
//	printf("genter : \n");
//	scanf("%s",&student1.genter);
//	printf("message : \n");
//	scanf("%s",&student1.massage);
//	
//	printf("\n你的信息:\n");
//	printf("name : %s\n",student1.name);
//	printf("age :%d\n",student1.age);
//	printf("日期: %d-%d-%d\n",student1.date.year,student1.date.month,student1.date.day);
//	printf("genter : %s\n",student1.genter);
//	printf("message : %s\n",student1.massage);
//	return 0;
//} 

1. 结构体变量作为函数参数 ： void Display(struct Data data);
2. 结构体变量的指针作为函数参数:   void Display(struct Data *pdata);  

宏定义分为 不带参数的 和 带参数的 
不带参的 :   #define TEST "I love you"
带参数的 :   #define TEST(a,b) (a*b)*2          (可以很好的替换函数的使用)
宏定义不是c语句，不需要再末尾加分号
使用 #undef命令终止宏定义的作用域，宏定义用于预处理语句，不同于定义的变量，只做字符替换，不分配内存空间。

引入自定义的c文件  #include
#include <*.h>               #使用尖括号系统会自动在系统c库函数头中找
#include "*.h"               #使用双引号系统会在当前目录找头文件，如果找不到，再到系统c库函数头中找
一个#include命令只能指定一个被包含的文件
文件包含是可以嵌套的，一个被包含的文件中可以包含另一个文件
「在头文件中定义定义函数和全局变量」这种认知是原则性的错误！不管是标准头文件，还是自定义头文件，都只能包含变量和函数的声明，不能包含定义，否则在多次引入时会引起重复定义错误。

链表
数据结构中有一种线性结构称为线性表(也称链表)。
当进行添加元素的时候，存储的个数就会随之该表，这种方式就是链表。
链表中每个元素包含数据部分跟指针部分。
链表必须利用指针才能实现。
动态链表分配内存函数:   malloc函数跟calloc函数(都是在内存中动态分配连续的内存空间数组，返回一个指针，该指针指向动态分配的连续内存空间地址。)
释放内存内存函数:   free函数



 c语言的内存组织方式:
 程序得到机器语言指令和数据都存储在同一个逻辑内存空间里。
程序被组织的4个逻辑段：
 1. 可执行代码
 2. 静态数据，可执行代码和静态数据存储在固定的内存位置。
 3. 动态数据，程序请求动态分配的内存来自内存池，也就是堆。
 4. 栈，局部数据对象，函数的参数，以及调用函数跟被调用函数的联系称为栈的内存池中。
 堆： 在内存的全局存储空间中，用于程序动态分配和释放的内存块称为自由存储空间。通常称为堆。需要程序员手动分配和释放。使用malloc跟free函数在堆中分配和释放。
 栈： 在程序声明局部变量和调用函数时，系统将自己动态分配内存。是一个后进先出的压入弹出式的数据结构。
 如果栈指针位于栈顶，则表示栈是空的，如果栈指针指向最下面的数据向的后一个位置，则表示的为满的。
 详解： C语言和内存_u014630142的博客-CSDN博客_c语言内存  https://blog.csdn.net/u014630142/article/details/82428028

__LINE__ 返回当前行号
__FILE__  返回当前文件名
#line 行号 "文件名"                       #line可以指定行号，文件名


#line 100 "c语言题"
#define NUM 50

//条件编译
int main()
{	
	#if NUM > 100
		printf("num是%d",NUM); 
	#elif NUM== 100
		printf("当前行号：%d\n",__LINE__);
		printf("当前文件名：%s",__FILE__);
	#else
		 printf("当前无内容");
	#endif
	return 0;	
} 

命名空间的自定义:
namespace Output{
	int sum,value;
	void pad
	{
		printf("我是pad函数");
	}
}
自定义命名空间的使用:  using namespace Output；  Output::sum,Output::value;
std::cout是在#include<iostream>库中的istream类型中的对象
std::cout<<a<<std::endl;
上条语句中<<是输入运算符,就是将大头的那边的量弄进箭头所指的对象中,并返回运算之后的箭头所指的对象
std::endl是一个操纵符,作用是结束当前行,并将与设备关联的缓冲区的内容刷到设备中,最好每个cout都加一个endl,利于清除缓存..
在cin中当遇到无效的输入时,比如cin>>v1>>v2,v1是int型,你却输入了a,就会返回一个无效的状态,后面的v2也输入不了.或者遇到文件结尾符时,也会返回一个无效的状态.
文件结尾符在window系统里通过Ctrl+Z键入,linux中通过Ctrl+D键入
实例:
using namespace std;
int main()
{
	int sum=0,value = 0;
	while(cin >> value)
	{
		sum += value;
	}	
	cout << sum << endl;
	return 0; 
} 


两种套接字各有优缺点：
无连接套接字传输效率高，但是不可靠，有丢失数据包、捣乱数据的风险； tcp
有连接套接字非常可靠，万无一失，但是传输效率低，耗费资源多。   udp

socket函数     #创建套接字
int socket(int af,int type,int protocol)       
af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6
type 为数据传输方式/套接字类型,常见的有SOCK_STREAM(流格式套接字/面向连接的套接字) 和 SOCK_DGRAM(数据报套接字/无连接的套接字)
protocol 表示传输协议，常用的有IPPROTO_TCP 和 IPPTOTO_UDP,分别表示TCP传输协议和UDP传输协议。


FILE *fp          #文件型指针变量，fp是一个指向FILE类型的结构体的指针变量
FILE f[5]         #定义了一个结构体数组f，它有5个元素。可以存放5个文件的信息
#函数的调用
    FILE *fp
    fp = fopen(文件名,打开方式)
    
fwirte函数的使用
FILE *fp;
   char str[] = "This is runoob.com";
 
   fp = fopen( "file.txt" , "w" );
   fwrite(str, sizeof(str) , 1, fp );
 
   fclose(fp);
fwrite(写入的元素指针,写入每个元素的的大小(以字节为单位)，元素的个数,FILE对象的指针)

字符读写函数 ： fgetc 和  fputc
字符串读写函数 :  fgets  和   fputs
数据块读写函数 :   freed  和   fwrite
格式化读写函数  ：    fscanf   和   fprintf

rewind 函数 设定FILE指针变量的文件的开头
fseek(FILE对象的指针,偏移量,开始位置)       #开始位置有:  SEEK_SET 文件的开头,  SEEK_CUR  文件指针的当前位置  ,   SEEK_END   文件的结尾

while (!feof(fp))
{
    ch = fgetc(fp);
    
}
ansic 提供了一个feof函数，用来判断文件是否真的结束。结束值为1，未结束值为0.
 
链表
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct linktable
{
        int data;
        struct linktable *next;
};

void test()
{
        struct linktable node1 = {10,NULL};
        struct linktable node2 = {20,NULL};
        struct linktable node3 = {30,NULL};
        struct linktable node4 = {40,NULL};
        struct linktable node5 = {50,NULL};
        struct linktable node6 = {60,NULL};


        node1.next = &node2;
        node2.next = &node3;
        node3.next = &node4;
        node4.next = &node5;
        node5.next = &node6;

        struct linktable *pro = &node1;
        while(pro != NULL)
        {
                printf("%d \t",pro->data);
                pro = pro->next;
        }
}

int main()
{
        test();
        return 0;
}#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct linktable
{
        int data;
        struct linktable *next;
};

void test()
{
        struct linktable node1 = {10,NULL};
        struct linktable node2 = {20,NULL};
        struct linktable node3 = {30,NULL};
        struct linktable node4 = {40,NULL};
        struct linktable node5 = {50,NULL};
        struct linktable node6 = {60,NULL};


        node1.next = &node2;
        node2.next = &node3;
        node3.next = &node4;
        node4.next = &node5;
        node5.next = &node6;

        struct linktable *pro = &node1;
        while(pro != NULL)
        {
                printf("%d \t",pro->data);
                pro = pro->next;
        }
}

int main()
{
        test();
        return 0;
}


<conio.h> 库 保存了些通过控制台数据输入和数据输出的函数  如: getch函数  getchar函数   _kbhit函数 _getch()函数

typedef 的作用 起别名   typedef int DD         (那DD就是有int性质 )

system("cls")               #清除屏幕内容

定义变量数组和结构体大型占内存的数据结构，在使用数组的时候经常因为没有初始化而产生乱码值。
使用memset函数进行 内容初始化
memset 一般使用“0”初始化内存单元，而且通常是给数组或结构体进行初始化。一般的变量如 char、int、float、double 等类型的变量直接初始化即可，没有必要用 memset。如果用 memset 的话反而显得麻烦。
#include <string.h>
char a[20];
memset(a,0,stdio)                        stdio 是基本输入流

带参数的主函数
main(int argc,char *argc[])              其中整数型 argc接受命令行参数的个数，指针数组参数argc[] 指向各个参数串

字符数组的内容是放在堆栈上，可以修改
字符指针变量的内容是放在静态存储区，不可以修改，在指针前加const 就可以修改

#include <stdlib.h>
#define random(x) rand()%X
生成一个小于x的随机数。rand()函数生成一个无符号型的随机数，然后模x，即结果为0到x内的一个随机数 ，然后将这个值赋给random(x)

c grapics.h库的使用: https://docs.easyx.cn/zh-cn/coordinate
circle函数进行画空心圆       circle(200,200,100)    圆心为200，200   半径为 100的图
·
fillellipse(圆心x，圆心y，x半径，y半径)              #fillelipse是画椭圆函数，当x半径跟y半径相等时就是实心圆。
cleardevice 进行清空背景色

itoa(数字,字符,10)             #函数功能是将数字转化为字符，10代表十进制

当调用一个函数时，实参变量和形参变量之间是值传递。

cpu 和 内存储器 称之为 主机

c语言 在执行过程中，不检查数组是否越界。

POINT 是c语言自带的结构体

GRB 颜色库  ：sioe.cn/yingyong/yanse-rgb-16/

3 % 5 = 3      小值 % 大值 = 小值本身

调用函数过程  ： 1. 给形参进行分配空间，将实参赋值给形参。2. 进入函数，为函数内部的局部变量分配空间，执行函数内部语句，到达return，返回值。 3. 将函数内部的局部变量和形参分配的空间进行释放。

枚举类的使用  ：
    好处 ： 有效的解决#define宏命名过多
    enum color {
	c0 = EGERGB(221, 191, 216),     // 格子色  0
	c1  = EGERGB(161, 150, 216),        //2
	c2 = EGERGB(221, 181, 135),         //4
	c3 = EGERGB(255, 215, 0),			//8
	c4 = EGERGB(255, 165, 0),          //16
	c5 = EGERGB(255, 99, 71),          //32
	c6 = EGERGB(255, 69, 0),           //64
	c7 = EGERGB(178, 34, 34),            //128
	c8 = EGERGB(112, 54, 34),             //256
	c9 = EGERGB(190, 30, 50),             //512
	c10 = EGERGB(20, 60, 54),             //1024
	c11 = EGERGB(52, 61, 166),            //2048
	back = EGERGB(0xFC, 0xFC, 0XFC),    //背景色

};

color Color[] = {c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, back};

printf("%d%d%d",&k,&k,&k)           输入 1 2 3

-k++        的运算顺序是 先++ 再负号       相当于 -(k++)     

局部变量 = 内部变量   
