当出现编码gbk的不可映射字符的解决方法: 这是因为代码中出现了中文,将编码格式改为ANSI格式即可。


定义变量注意事项:
	1.未初始化不可使用
	2.float定义值时后面必须要加F，long定义值时后面必须要加L。

数据类型中布尔值定义:    boollean a = True/FALSE;
数据类型中字符串定义:    String s = "字符串内容";                 //这里采用string构造方法进行直接创建字符串对象

强制类型转换注意事项:
	只能是将大类型的值或变量强制转化为小类型的值或变量


字符/字符串 + 加操作注意事项:
	1.字符 + int型   是以对应的ascii码进行相加
	2.字符串 + 任意类型时 是以拼接的形式进行连接运算。当出现多个 + 操作时，按照从左到右的顺序进行执行。

数据流输入：
	1. 先导入Scanner包  import java.util.Scanner
	2. 创建对象: Scanner sc = new Scanner(System.in)
	3. 调用输入方法: nextInt() 输入整数  next() 输入字符串   nextDouble() 输入double类型数据
	例句:
		Scanner sc = new Scanner(System.in);
		System.out.println("输入第一身高: ");
		int h1 = sc.nextInt();
		System.out.println("输入第二身高: ");
		int h2 = sc.nextInt();
		System.out.println("输入第三身高: ");
		int h3 = sc.nextInt();
		int max = h1>h2?h1:h2;
		max = max>h3?max:h3;
		System.out.println("最高身高是：" + max);
		sc.close();

数据流输出:
	System.out.print(msg)      //输出一个字符串，不带换行
	System.out.println(msg)         //输出一个字符串，带换行
	System.out.printf("%s",msg)        //格式化数据流输出一个字符串


if结构:
	if(表达式) else if  else;

switch结构:
	switch(表达式){case 值:表达式; case 值:表达式:......}

for循环结构:
	for(初始化;表达式;更新){}

Java 增强的for循环: (内部原理就是iterator迭代器)
    作用: 非常简便的遍历数组和列表元素

	for(声明语句:表达式){代码句子}
	例句:
	int numbers[] = {123,789,6565,4564};
	for(int x:numbers)             //x是循环个体，numbers循环体。
	{
		System.out.println(x);
	}

while循环结构:
	while(表达式);

do while结构:
	do{}while(表达式);


随机数:
	1.导入Random包    import java.util.Random
	2.创建对象     Random r = new Random();
	3.int number = r.nextInt(10)      获取数据的范围: [0,10) 包括0,但是不包括10。
	例句:
		String s = "随机值是";
		Random r = new Random();
		int number = r.nextInt(50);
		System.out.print(s);
		System.out.println(number);


数组:
	int arr[] = new int[3];
	左边:
		int: 说明数组的元素是int类型
		[]: 说明这是一个数组
		arr: 这是数组的名称
	右边:
		new: 为数组申请内存空间
		int: 说明数组中的元素是int类型
		[]: 说明这个是数组
		3: 数组长度，其实就是数组中的元素的个数

	动态初始化: 数据类型 数组名称[] = new 数据类型[数据长度]
	例句:
		char ch[] = new char[5];
		ch[0] = 'a';
		ch[1] = 'b';
		ch[2] = 'c';

	动态初始化时，系统会为数组设置默认值:
		1. 整数型: 默认值0
		2. 浮点型: 默认值0.0
		3. 布尔值: 默认值是false
		4. 字符: 默认值是空字符
		5. 引用数据类型: 默认值是null

	静态初始化: 数据类型 数组名称[] = {元素一，元素二，元素三......}
	例句:
		char ch[] = {'a','b','c'};

	多数组指向同一个内存空间:
		int arr[] = new int[3];
		arr[0] = 100;
		arr[1] = 200;
		arr[2] = 300;
		System.out.println(arr[0]);               // 100
		int arr1[] = arr;
		arr1[0] = 2000;
		System.out.println(arr[0]);           //2000
		System.out.println(arr1[0]);          //2000
		这里arr1指向arr，是深拷贝，arr1跟arr指向的是同一内存地址。

	索引越界，访问了数组中不存在的索引对应的元素(ArrayIndexOutOfBoundsException):
		int arr[] = new int[3];
		arr[4] = 5000;                       //这里索引为4，超出范围
	空指针异常，访问的数组已经不再指向堆内存中的数据(NullPointerException)：
		int arr[] = new int[3];
		arr = null;                            //这里数组指向null，null为空值，表示不指向任何有用的有效对象，所以下面打印的时候出现报错
		System.out.println(arr[0]);

	求数组元素的个数:
		int arr[] = {1,2,3,4,5,6};
		System.out.println(arr.length);               //arr.length 就是求数组arr中元素的个数

	使用java强for循环进行数组的遍历:
		int numbers[] = {123,789,6565,4564};
		for(int x:numbers)
		{
			System.out.println(x);
		}

    进行数组的复制
        System.arraycopy(源数组，源数组要复制的起始位置，目的数组)

方法:
	定义格式:
		public static 返回值类型 方法名(数据类型 形参名称一,数据类型 形参名称二，......)
		{
			//方法体内容
		}
	调用格式：
		方法名(实参一，实参二...);
	注意事项:
	1.必须先定义再调用，位置前后无所谓
	2.方法不能嵌套定义

	方法重载:
		方法名可以相同，但是参数不可以相同，与返回值类型无关
	方法重载的意义: 使得方法内参数可以兼容多种类型，方法名还不变

	方法参数的传递:
		1.对于基本数据类型的参数，形式参数的改变，不会影响实际参数的值
		2.对于数组类型的参数，形式参数的改变会直接影响实际参数的值



方法中的可变参数:
    在方法的参数类型中添加...进行传递同一类型的多个参数
    格式:  public static double show(double... flag)               //可变参数其实也是数组，编译器编译过程中悄悄修改
    例句:
        public static double show(double... flag)
        {
            double max = flag[0];
            for(int i=1;i<flag.length;i++)
            {
                if(max < flag[i]) max = flag[i];
            }

            return max;
        }


类与对象:
    类的定义:
        每个文件可以有多个类，但是只能有一个public类，并且这个public类必须与文件同名，其余类任意即可
    例句:
        class Student
        {
            String name = "孟海平";                    //定义成员变量
            int age = 22;
            public void stumessages()              //定义方法
            {
                System.out.println("名字: " + name);
                System.out.println("年龄: " + age);
            }
        }

    调用对象:
        1.使用成员变量
            格式: 对象名.成员变量名
            例句: p.name
        2.使用成员方法
            格式: 对象名.方法名
            例句: p.stumessages()
    例句:
        Student p = new Student();
        p.name = "张杰";
        p.age = 32;
        p.stumessages();


    成员变量: 类之内，成员方法之外的变量
    局部变量: 类之内，成员方法之内的变量


    关键字:
        private关键字:
            1.是一个权限修饰符
            2.可以修饰成员(成员方法与成员变量)
            3.作用是保护成员不被其他类使用，被private修饰的成员只能在本类中使用
            针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作:
                1.提供get变量名() 方法，用来获取成员变量的值，方法使用public进行修饰
                2.提供set变量名(参数) 方法，用来设置成员变量的值，方法使用public进行修饰

            例句:
                class Student
                {
                    private String name;
                    private int id;
                    private double score;

                    public void setstudent(String names,int ids,double scores)
                    {
                        name = names;
                        id = ids;
                        score = scores;
                    }

                    public String getName()
                    {
                        return name;
                    }

                    public int getId()
                    {
                        return id;
                    }

                    public double getScore()
                    {
                        return score;
                    }

                }


                public class Mhp
                {
                    public static void main(String args[])
                    {
                        Student s = new Student();
                        s.setstudent("孟海平",22,98.3);

                        System.out.println("名字: "+ s.getName());
                        System.out.println("学号: "+ s.getId());
                        System.out.println("成绩: "+ s.getScore());
                     }

                  };
        thiis关键字:
            1.this修饰的变量用于指代成员变量
                当方法的形参跟成员变量同名时，不带this的是形参，带this的是成员变量
            2.解决局部变量隐藏成员变量的时候使用this关键字
            3. this 代表所在类的对象的引用
                方法被哪个对象所使用时，this就代表哪个对象


    构造方法:
        作用: 创建对象
        功能: 完成对象数据的初始化
        格式:
            修饰符 类名(参数)
            {
                   //代码
            }
            修饰符一般用: public
        注意:
            1.构造方法可以设定默认的值
            2.当没有定义构造方法时系统会自动给出一个默认的无参构造方法，如果定义则不再使用系统给出的
            3.如果自定义了带参构造方法，还要使用无参的构造方法，那就必须再写一个无参的构造方法

        例句:
            class Student
            {
                private String name;
                private int id;
                private double score;

                public Student()
                {
                    System.out.println("我是无参构造方法");
                }

                public Student(String name,int id,double score)
                {
                    this.name = name;
                    this.id = id;
                    this.score = score;
                 }
            }

            Studnet s = new Student("张磊磊"，22,99.5);


String对象的特点:
    1.使用 String s1 = new String()  String s1 = new String() 创建对象时，每new一个就会申请一个内存空间，这里s1和s2指向的是不同的内存空间
    2.使用 String s3 = "abc"  String s4 = "abc" 这种是直接创建字符串对象，内容存放在堆中常量池中，这里s3和s4指向的是一个内存空间


String对象字符串比较:
    使用 == 做比较
        1. 基本数据类型: 比较的是数据值是否相同
        2. 引用类型: 比较的是地址值是否相同
    注意: 当想要引用数据类型进行数据值的比较的时候: 使用String的equals()方法进行比较 ,equals方法返回类型是boolean类型
    例句:
        char s[] = {'a','b','c'};
        String s1 = new String(s);
        String s2 = "abc";
        System.out.println(s1.equals(s2));                 //返回True

    charAt(索引值)  可以打印出字符串中每个字符
    例句:
        String sc = "abcdcefg";
        for(int i=0;i<sc.length();i++)                         //sc.length()   用于获取String 的字符串长度
            System.out.println(sc.charAt(i));

类的静态方法与静态变量:  https://blog.csdn.net/qq_51334663/article/details/113686583
    例句:
        public class Mhp
        {
            public static void main(String args[])
            {
                int arr[] = {1,2,3,4,5};
                System.out.println(sarry(arr));          //静态方法无须创建实例，在本类中可以直接使用，如果是外部调用时，直接 类名.static方法名

            }

            public static String sarry(int arr[])                  //这里就是静态方法
            {
                String s="[";
                int i;
                for(i=0;i<arr.length;i++)                //arr.length 获取整形数组的长度
                {
                    s += arr[i];
                }
                s+="]";
                return s;
            }

        };


String和StringBuilder区别:
    1.String的字符串内容是不可变的，每次 String s="abac"; s+="sadasd"; 都会申请新的内存空间进行存放新拼接的字符串
    2.StringBuilder的字符串是可变的，使用格式是 StringBuilder s = new StringBuilder("ABC"); s.append("abcddd").append("adafda").append(1313),添加后的任意内容都是存放在首次new出来对象的内存空间里



StringBuilder构造方法使用
    1. public StringBuilder()   创建一个空白可变字符串对象，不含任何内容
    2. public StringBuilder(String str)     根据字符串的内容，来创建可变的字符串对象

StringBuilder的添加和反转字符串
    例句:
    	StringBuilder str = new StringBuilder("mhp");
	    str.append(121).append("zll").append("fadfafasd");                     //这个是链式编程添加，append(任意类型)
	    System.out.println(str);
	    str.reverse();                                    //进行对字符串进行反转
	    System.out.println(str);

String和StringBuilder相互转化
    String转StringBuilder:
        StringBuilder s = new StringBuilder("1231");即可
    StringBuilder转String:
        String st = st.toString();即可
    例句:
        String s = "mhp";
        StringBuilder st = new StringBuilder(s);
        st.append(123).append("all");
        String str = st.toString();
        System.out.println(st);
    注意: 为啥要进行转化?
        因为StringBuilder有两个好用的方法，append和reverse，并且比String每次拼接添加省内存空间


随机生成任意字符串:
    public class Mhp
    {
        public static void main(String args[])
        {
            String s = "abcdefghigklmnopqrstuvwxyz1234567890!#$";
            System.out.println(sarry(s));
        }

        public static String sarry(String strs)
        {
            int i;
            Random str = new Random();
            StringBuilder s = new StringBuilder();
            for(i=0;i<=15;i++)
            {
                int a = str.nextInt(strs.length());
                s.append(strs.charAt(a));
            }
            String sss = s.toString();
            return sss;
        }
    };



程序退出:  System.exit(0)

继承:
    格式:  class 子类名 extends 父类名{........}
    supper关键字和this关键字用法
        this: 代表本类对象的引用
        supper: 代表父类存储空间的标识(可以理解为父类对象的引用)
                        访问成员变量                            访问构造方法                       访问成员方法
        this          this.成员变量(访问本类的)                this.构造方法(访问本类的)          this.成员方法(访问本类的)
        supper        supper.成员变量(访问父类的)              supper.构造方法(访问父类的)        supper.成员方法(访问父类的)

    例句:
        class Fu{
            String name = "mjt";
        }

        class Zi extends Fu{
            String name = "zll";

            public Zi(){
                String names = "mhp";
                System.out.println(names);                //打印局部变量
                System.out.println(this.name);             //打印本类成员变量
                System.out.println(super.name);            //打印父类成员变量
            }
        }

        public class Mhp{
            public static void main(String args[])
            {
                Zi data = new Zi();
            }
        }


    继承中构造方法的访问特点:
        子类中所有的构造方法都会默认访问父类中的无参构造方法，因为每个子类构造方法的第一条语句默认都是 : super()
    当父类中没有无参构造方法，只有带参构造方法的时候:
        1. 通过使用super关键字去显示调用父类的带参构造方法
        2. 在父类中自己定义一个无参构造方法


    继承注意点:
        1. 子类继承父类后，再子类中重写父类的成员变量值和成员方法时，会覆盖掉父类的成员变量值和成员方法
        2. 只有在使用子类的构造方法时，优先会调用父类的无参构造方法，当子类中没有写任何构造方法时，调用子类的构造方法也是执行父类的构造方法
        3. 通过一个子类对象访问一个成员变量或者成员方法时，先在子类范围中找，如果找不到，再从父类的范围中找，，如果还找不到，直接报错。

    @override 这个用于检测子类方法重写的正确性

    方法重写的注意事项:
        1. 父类的私有方法是不可以被重写的
        2. 子类的方法权限不能比父类的低 (public > default(不写修饰符时默认的) > private)

    继承的注意事项:
        java支持单继承与多层继承
        多层继承:
            Class Gradfather{.....}
            Class Father extends Gradfather{.....}
            Class son extends Father{....}


申明方法格式:  修饰符 返回类型 方法名(形参){}

final常量修饰符
    final关键字是最终的意思，可以修饰方法，类，变量
    1. 修饰变量时，申明该变量是一个常量，不能被再次赋值
    2. 修饰方法时，申明该方法是最终方法，该方法不能被重写
    3. 修饰类时，申明该类是最终类，不能进行继承

    注意 :
        1. 变量为基本数据类型 : final修饰的基本数据类型值不能变
        2. 变量为引用数据类型 : final修饰的引用数据类型地址不能发生改变，但是值可以发生改变

static静态修饰符
    非static的成员方法:
        1.能访问静态的成员变量
        2.能访问非静态的成员变量
        3.能访问非静态的成员方法
        3.能访问静态的成员方法
    static的成员方法:
        1.只能访问静态的成员变量
        2.只能访问静态的成员方法


多态
    三大必要条件:
        1. 继承
        2. 重写
        3. 父类引用指向子类对象

    格式 : 父类名 变量名 = new 子类名()

    例句:
        class Animal
        {
            public int age = 40;

            public void show()
            {
                System.out.println("我是父类");
            }
        }

        class Dog extends Animal
        {
            public int age = 20;

            @override
            public void show()
            {
                System.out.println("我是子类");
            }

            public void eat()
            {
                System.out.println("狗爱吃骨头");
            }
        }

        public class Mhp {
            public static void main(String args[])
            {
                animal a = new dog();
                System.out.println(a.age);             //多态的成员变量，左编译，左运行，所以这个值是40
                a.show();                      //多态的成员方法,左编译，右运行，所以这个值是 我是子类
            }
        }
    多态中成员访问特点:
        1. 访问成员变量时，编译看左边，执行看左边
        2. 访问成员方法时，编译看左边，执行看右边
        不同的原因是: 成员方法有重写，而成员变量没

    多态的好处和弊端:
        好处: 提高了程序的扩展性,使用父类作为参数，在使用的时候，使用具体的子类进行参与操作
        坏处: 不能使用子类的特有功能，因为没有进行重写父类的方法

    向上转型和向下转型:
        向上: 从子到父        父类引用子类对象
            例句:
                animal a = new dog();
                a.show();

        向下: 从父到子        父类引用子类对象
            例句:
                animal a = new dog();
                a.show();
                Dog c = (Dog)a;                 //进行强转即可
                c.eat();


抽象类
    1. 抽象类和抽象方法必须使用abstract关键字就行修饰
        public abstract class 类名{}
        public abstract void eat();
    2. 抽象类中不一样有抽象方法，有抽象方法的类一定是抽象类
    3. 抽象类不能进行实例化
        抽象类想要进行实例化操作时，必须要进行子类对象实例化，这叫抽象多态
    4. 抽象类的子类
        要么重写父类的抽象方法
        要么是抽象类

    例句:
        abstract class Animal{

            public String name;
            public int age;

            public Animal(){}

            public abstract void eat();
        }

        class Cat extends Animal{
            public String name;
            public int age;

            public Cat(){}

            public Cat(String name,int age)
            {
                this.name = name;
                this.age = age;
            }


            @Override
            public void eat()
            {
                System.out.println("猫爱吃鱼");
            }

            public void tx()
            {
                System.out.println("猫抓老鼠");
            }

            public void setName(String name)
            {
                this.name = name;
            }

            public void setAge()
            {
               this.age  = age;
            }

            public String getName()
            {
                return this.name;
            }

            public int getAge()
            {
                return this.age;
            }

        }

        class Dog extends Animal{
            public String name;
            public int age;

            public Dog(){}

            public Dog(String name,int age)
            {
                this.name = name;
                this.age = age;
            }

            @Override
            public void eat()
            {
                System.out.println("狗爱吃骨头");
            }

            public void tx()
            {
                System.out.println("看家");
            }

            public void setName(String name)
            {
                this.name = name;
            }

            public void setAge()
            {
                this.age = age;
            }

            public String getName()
            {
                return this.name;
            }

            public int getAge()
            {
                return this.age;
            }

        }

        public class Mhp {
            public static void main(String args[])
            {
                Cat c = new Cat("橘猫",22);
                System.out.println(c.name);
                System.out.println(c.age);
                c.eat();
                c.tx();
                Dog d = new Dog("花狗",29);
                System.out.println(d.name);
                System.out.println(d.age);
                d.eat();
                d.tx();
            }
        }


    抽象类成员特点:
          成员变量：既可以是变量，也可以是常量。
         abstract是否可以修饰成员变量？不能修饰成员变量
         构造方法：有
            用于子类访问父类数据的初始化。
         成员方法：既可以是抽象的（子类直接重写父类的抽象方法），也可以是非抽象的非抽象的子类直接继承就可以使用。
         抽象方法: 是限定子类必须要做某些事情


接口
    接口用关键字interface修饰
        public interface 接口名{}
    类实现接口用implements表示
        public class 类名 implements 接口名{}
    接口一般不能进行实例化，但是可以参照多态的方式，通过类对象实例化，这叫接口多态
    多态的形式: 具体类多态，抽象类多态，接口多态

    接口是隐式抽象的，当声明一个接口的时候，不需要写上abstract关键字
    接口中的每一个方法也是隐式抽象的，当声明一个方法的时候，同样也不需要写上abstract关键字

    接口的成员特点:
        成员变量都是默认静态常量，成员只有抽象方法来规定限制子类行为，没有非抽象类方法

    接口的实现:
        实现接口的时候，类一定要重写接口中的所有方法，否则，类必须申明为抽象类
        类使用implemtnts关键字进行实现接口，在类声明中，implements关键字放到class的后面

        格式:  public class 类名 implements 接口名{....}

接口和抽象类的区别:
    成员变量和成员方法:
        类: 可以有抽象方法和非抽象方法，final 变量 和 局部变量，有构造方法
        接口: 只有final常量 和 抽象方法

    继承和实现方面：
        类: 通过子类继承父类
        接口: 通过类实现接口的方式进行，绕后类重写接口的方法

形参和返回值是类
    1. 方法的形参是类名，其实需要的是该类的对象
        格式: public void 方法名(类名 类变量名)
    2. 方法的返回值是类名，其实返回的是改类的对象
        格式: public 类名 方法名() { 类名 类变量名 = new 类名 ; return 类变量名}



形参和返回值是抽象类和接口
    1. 方法的形参是抽象类或接口，需要的是该抽象类的对象或接口的对象
        格式: public void 方法名(抽象类名 抽象类变量名)
              public void 方法名(接口名 接口变量名)
    2. 方法的返回值是抽象类或接口，需要的是该抽象类的对象或接口的对象，采用多态的方式进行
        格式: public 抽象类名 方法名(){抽象类名 抽象类变量名 = new 子类类名(); return 抽象类变量名 }
        格式: public 接口名 方法名(){接口名 接口变量名 = new 子类类名(); return 接口变量名 }

     例句:
        abstract class Aniaml{

            private String name;
            private int age;

            public Aniaml(){

            }

            public Aniaml(String name,int age)
            {
                this.name = name;
                this.age = age;
            }

            public abstract void eat();

        }

        class Cat extends Aniaml implements Jump{
            public Cat() {
            }

            public Cat(String name, int age) {
                super(name, age);
            }

            @Override
            public void eat()
            {
                System.out.println("吃鱼");
            }


            public void show()
            {
                System.out.println("1234546");
            }
        }


        class Text{

            public void gets(Aniaml a)
            {
                a.eat();
            }

            public Aniaml show()
            {
                Aniaml a = new Cat("橘猫",22);
                return a;
            }


            public void aaa(Jump a)
            {
                a.show();
            }

            public Jump bbb(){
                Jump b = new Cat();
                return b;
            }

        }


        public class Mhp{
            public static void main(String args[])
            {
                Text c = new Text();
                Jump b = c.bbb();
                c.aaa(b);
            }
        }



内部类:
    1. 成员内部类 : 一个类在另一个类的内部
        格式: public class Hh
        {
            class Dd{
                ....
            }
        }
        注意:
            成员内部类可以无条件访问外部类的所有成员属性和成员方法
            外部类想要访问内部类时，需要进行创建一个成员内部类的对象，再通过这个对象进行访问引用。

        成员内部类调用:
            1. 外部类名.内部类名 a = new 外部类().new 内部类();
                Test.Ha a = new Test().new Ha();
                a.show();
            2. 在外部类定义一个方法，在方法中new一个内部类对象，进行实例化使用。

       例句:
            class Test{
                private int age=20;

                class Ha{
                    public void show()
                    {
                        System.out.println("我是成员内部类");
                        System.out.println(age);
                    }
                }

                public void method()
                {
                    Ha s = new Ha();
                    s.show();
                }
            }

            public class Mhp{
                public static void main(String args[])
                {
                    Test s = new Test();
                    s.method();

                    Test.Ha a = new Test().new Ha();
                    a.show();
                }
            }



    2. 局部内部类: 一个类在另一个类的方法里
        格式: public class Test
        {
            public void methos()
            {
                class C{
                    ....
                }
            }
         }
         注意:
            局部内部类是在方法中定义的类，所以外界是无法直接使用的，需要在方法内部创建使用，该类可以直接访问外部类的成员，也可以访问方法内的局部变量

    3. 匿名内部类: 在方法中定义的new对象类
        格式: new 类名(){
                public void show()
                {
                ...........;
                }
            };
         1.调用一个方法:
            new Cat()
            {
                public void show()
                {
                    System.out.println("132");
                }
            }.show();
         2. 调用多个方法:
            Cat s = new Cat()
            {
                public void show()
                {
                    System.out.println("我是匿名类show");
                }
                public void jump()
                {
                    System.out.println("我是匿名内部类jump");
                }
            };
            s.show();
            s.jump();




toString : 将整形值转变为字符串内容
	例句:   Integer x = 5;
			System.out.println(x.toString()+"23");
currentTimeMillis : 返回当前时间以毫秒表示,返回值为long
	例句:   long start = System.currentTimeMillis()
枚举:
	格式: enum 枚举名{枚举内容}
	  例句:
		public class HelloWorld {
			enum Color{
				red,blue,green;
			}

			public static void main(String args[]) {
				for(Color x:Color.values())                     //values方法可以获取到枚举中的所有元素
				{
					System.out.println(x);
				}
			}
		}


Arrays类 : 包含操作数组的各种方法（前提是必须导入 import java.util.Arrays）
public static String toString(int a[])        //将数组内容拼接成字符串进行返回
public static void sort(int a[])              //按照数字顺序排列指定的数组
例句:
int arr[] = {20,51,7,10,5};
System.out.println(Arrays.toString(arr));
Arrays.sort(arr);
System.out.println(Arrays.toString(arr));



基本数据类型包装类
将基本数据类型封装成对象的好处在于: 对象可以定义更多的功能方法操作该数据
常用的操作之一: 用于基本数据类型与字符串之间的转换
byte -> Byte     short -> Short    int -> Integer   long -> Long    float -> Float    double -> Double
char -> Character        boolean -> Boolean
例句:
System.out.println(Integer.MAX_VALUE);             //得到int类型的最大值
System.out.println(Integer.MIN_VALUE);             //得到int类型的最小值


字符串跟基本类型的相互转换
	1.基本数据类型到字符串转换
		public static String valueOf(基本数据类型)           //利于方法重载进行所有的基本数据类型进行跟字符串的转换
		格式: String s = String.valueOf(5);

	2.字符串到int类型的转换
		public static Integer parseInt(String s)              //将字符串类型变为int数据类型
		格式: int x = Integer.parseInt("46");

自动装箱和拆箱
	1.装箱: 把基本数据类型转换为对应的包装类类型
		例句:
			Integer i = 100;       //这是自动装箱
	2.拆箱: 把包装类类型转换为对应的基本数据类型
		例句:
			Integer i += 100;     =>  i = i.intvalue() + 100    //其中的 i.intvalue() 是自动拆箱,将包装类类型变成基本数据类型, Integer i = i.intvalue() + 100是自动装箱
	注: 在使用包装类的时候，如果做操作，最好先判断是否为null。
		我们推荐的是，只要是对象，在使用就必须进行判断不为null。

try catch异常处理语句
    格式:
        try
        {
            逻辑代码块1；
        }catch(ExceptionType e)
        {
            处理代码快1;
        }
    处理代码块中可以使用3个方法输出异常信息
        1. printStackTrace()方法  : 指出异常的性质，类型以及出现在程序中的位置
        2. getMessage()方法 : 输出错误的性质
        3. toString()方法 : 给出异常的类型与性质
    处理过程: 如果 try 语句块中发生异常，那么一个相应的异常对象就会被拋出，然后 catch 语句就会依据所拋出异常对象的类型进行捕获，并处理。处理之后，程序会跳过 try 语句块中剩余的语句，转到 catch 语句块后面的第一条语句开始执行。
    注:
        1. catch语句的参数类似方法的声明，包括一个异常类型与异常对象，异常类型必须是Throwable的子类。
        2. 一个catch语句也可以捕捉多个异常类型，这时它的异常参数可以是多个异常类型的父类。


异常与错误
	异常(Exception) 有两个重要的子类:  运行时异常(RuntimeException) 与 编译时异常(Exception及其子类)
	注: 
		运行时异常及其子类表示"JVM常用操作"引发的错误，例如: 试图使用空值对象引用(NullpointerExcption),除数为零(ArithmeicException)或数组越界(ArrayIndexOutOfBoundException)，一般都是人为的逻辑代码异常。


自定义异常类 : 先自定义一个类然后继承Exception异常类即可
    步骤：
        1. 继承Exception
        2. 自定义实现的构造方法
        3. 需要使用的时候，使用 throw new 自定义异常的名称
    throws:
        1. 用在方法申明后，跟的是异常类名
        2. 表示抛出异常，由该方法的调用者来进行处理
        3. 表示出现异常的一种可能性，并不会一定发生这些异常
    throw:
        1. 也在方法体内部，跟的是异常对象名
        2. 表示抛出异常，有方法体内的语句处理
        3. 执行throw一定抛出了某种异常



单线程并发修改异常原理:
    我在这个地方简述一下这个异常出发的大致原理；
    1.首先ArrayList类中有一个共享变量modCount，我们每操作一次集合这个变量都会进行加一操作（增，删，改，不包含查询）
    2. 我们在开始遍历集合元素的时候，会记录此时的modCount作为expectedModCount，每次遍历一个元素的的时候都会检查，这两个参数是否相等；如果不想等就会抛出ConcurrentModifyException
    异常案例:
        List<String> e = new ArrayList<>();
        e.add("mjh");
        e.add("masddjh");
        Iterator<String> it = e.Iterator();
        while(it.hasNext())
        {
            String s = it.next();
            if(s.equals("mjh"))
            {
                e.add("mhp");
            }
        }
        System.out.println(e);

    解决方案:(是list列表迭代器):
        ListIterator<String> it = e.listIterator();         //ListIterator (列表迭代器)
        while(it.hasNext())
        {
            String s = it.next();
            if(s.equals("mjh"))
            {
                it.add("mhp");             //使用列表迭代器的add方法进行加操作后，共享变量modcount和expcetedmodcout都会进行重新赋值，使得两个值一样，从而不会发生并发异常。
            }
        }
        System.out.println(e);

集合类体系结构
    一、单列 (Collection)

        注: Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。

        例句:
            Collection<String> s = new ArrayList<>();         //利用多态的方式进行使用Collection集合体
                    s.add("mhp");
                    s.add("zll");
                    s.add("zml");                 //add()方法进行添加元素

                    System.out.println(s.contains("zll"));      //contains()方法进行查找指定内容在集合中是否存在

                    s.remove("zll");           //remove()方法进行删除指定内容在集合中

                    System.out.println(s);

                    s.clear();              //clear()方法 进行对集合中的所有元素进行全部清除

                    System.out.println(s.isEmpty());         //isEmpty()方法是判断集合是否为空

                    System.out.println(s);
        colletion集合遍历
            遍历(Iterator) 使用Collection集合的iterator方法进行生成一个itr子类
                public Itr iterator()
                {
                    return new Itr;
                }

        例句:
            import java.util.Collection;
            import java.util.ArrayList;
            import java.util.Iterator;

            //标准类
            class Student
            {
            	private String name;
            	private int age;

            	public Student(){}
            	public Student(String name,int age)
            	{
            		this.name = name;
            		this.age = age;
            	}

            	public void setName(String name)
            	{
            		this.name = name;
            	}

            	public String getName()
            	{
            		return this.name;
            	}

            	public void setAge()
            	{
            		this.age = age;
            	}

            	public int getAge()
            	{
            		return this.age;
            	}

            }

            public class HelloWorld {
                public static void main(String []args) {
            		Collection<Student> s = new ArrayList();
            		Student a1 = new Student("mhp",22);
            		Student a2 = new Student("zll",23);

            		s.add(a1);         //将下面的两个student数据类进行添加
            		s.add(a2);

            		Iterator<Student> c = s.iterator();             //通过Collection的iterator方法进行生成迭代器对象
            		while(c.hasNext())           //hasNext()方法进行判断集合中下一个数据是否存在
            		{
            			Student ss = c.next();                  //next()方法进行执行下一个数据流
            			System.out.println("名字: " + ss.getName() + ",年龄: " + ss.getAge());
            		}
                }
            }


        1. list (元素内容可重复,数据内容是从下标为0开始的有序集合)
            list的遍历: 使用for循环打印集合内个数，使用get方法进行得到每个内容值
            例句:
                import java.util.ArrayList;
                import java.util.List;
                import java.util.Iterator;

                class Student
                {
                    private String name;
                    private int age;

                    public Student(){}
                    public Student(String name,int age)
                    {
                        this.name = name;
                        this.age = age;
                    }

                    public void setName(String name)
                    {
                        this.name = name;
                    }

                    public String getName()
                    {
                        return this.name;
                    }

                    public void setAge()
                    {
                        this.age = age;
                    }

                    public int getAge()
                    {
                        return this.age;
                    }

                }


                public class Demo
                {

                    public static void main(String args[])
                    {

                        List<Student> e = new ArrayList<>();                 //使用多态的方式进行实例化ArrayList子类，因为List是接口，不能直接使用，必须使用实现类对象进行调用
                        Student s1 = new Student("mhp",12);
                        Student s2 = new Student("zll",56);

                        e.add(s1);
                        e.add(s2);

                        for(int i=0;i<e.size();i++)           //使用for循环进行打印
                        {
                            Student s = e.get(i);
                            System.out.println(s.getName() +  "  ," + s.getAge() );
                        }

                        Iterator<Student> it = e.iterator();                //使用迭代器进行打印
                        while(it.hasNext()){
                            Student s = it.next();
                            System.out.println(s.getName() +  "  ," + s.getAge() );
                        }

                    }
                }

            具体类:
                1. ArrayList
                    集合ArrayList
                        ArrayList集合就是可变长的数组，数据空间大小可以进行改变
                        定义格式: ArrayList<存放内容类型> 对象名称 = new ArrayList<>();     //jdk7以后可以省略后面<>的内容，之前不可以
                        集合的增删改查:
                            //创建一个空个集合对象
                            ArrayList<String> arry = new ArrayList<>();
                            System.out.println(arry);
                            //增
                            arry.add("mhp");
                            arry.add("zll");
                            arry.add("zml");
                            System.out.println(arry);
                            //删
                            arry.remove("zll");
                            System.out.println(arry);
                            //改
                            arry.set(1,"hm");
                            System.out.println(arry);
                            //查
                            System.out.println(arry.get(0));
                            System.out.println(arry.get(1));
                        获取集合元素的个数:
                            System.out.println(arry.size());
                        注意:
                            1.当add加完后，下标就已经确定，再进行删改查操作时不得超过add后集合所有数据的下标，不然容易出现越界报错

                2. LinkedList
        2. set (元素内容不可重复，且数据顺序不唯一，是无序的集合)
    二、双列 (Map)



















